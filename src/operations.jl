# Methods to transform or combine posets  

"""
    reverse(p::Poset)::Poset

Create the dual of `p`, i.e., a poset with the same elements but with 
all relations reversed. May also be invoked as `p'`.
"""
function reverse(p::Poset)::Poset
    return Poset(reverse(p.d))
end

adjoint(p::Poset) = reverse(p)

"""
    (+)(p::Poset, q::Poset)::Poset

`p+q`is the disjoint union of posets `p` and `q`. Also `hcat(p,q)`.
"""
function (+)(p::Poset, q::Poset)::Poset
    np = nv(p)
    nq = nv(q)

    Zp = zeta_matrix(p)
    Zq = zeta_matrix(q)

    A = zeros(Int, np, nq)

    ZZ = [Zp A; A' Zq]
    return Poset(ZZ)
end

hcat(p::Poset, q::Poset) = p + q

"""
    (/)(p::Poset, q::Poset)::Poset

`p / q` creates a new poset by stacking `p` above `q`. Also `vcat(p,q)`
"""
function (/)(p::Poset, q::Poset)::Poset
    np = nv(p)
    nq = nv(q)

    Zp = zeta_matrix(p)
    Zq = zeta_matrix(q)

    A = zeros(Int, np, nq)
    B = ones(Int, nq, np)

    ZZ = [Zp A; B Zq]
    return Poset(ZZ)
end

vcat(p::Poset, q::Poset) = p / q

"""
    (\\)(p::Poset, q::Poset)

`p \\ q` creates a new poset by stacking `q` above `p`. 
Equivalent to `q / p`.
"""
(\)(p::Poset, q::Poset) = q / p

"""
    intersect(p::Poset, q::Poset)

The intersection of posets `p` and `q`. This is a new poset 
in which `v < w` if and only if `v < w` in both `p` and `q`.
The number of elements is the smaller of `nv(p)` and `nv(q)`.

May also be invoked as `p ∩ q`.
"""
intersect(p::Poset, q::Poset) = Poset(p.d ∩ q.d)

"""
    _chain2list(p::Poset)

Given a (chain) poset `p`, return a list of integers
whose entries are the elements of `p` in ascending order.

See also `_chain_sort`.
"""
function _chain2list(p::Poset)::Vector{Int}
    return sortperm([indegree(p.d, v) for v in 1:nv(p)])
end

"""
    linear_extension(p::Poset)::Poset

Return a linear extension of `p`. This is a total order `q` with 
the same elements as `p` with `p ⊆ q`.
"""
function linear_extension(p::Poset)::Poset
    return chain(_chain2list(p))
end

"""
    _chain_sort(p::Poset, ch::Vector{T}) where {T<:Integer}

`ch` is a list of vertices of `p`, preferrably a chain. Return the list sorted 
according to the `<` relation of `p`. 

See also `_chain2list`.
"""
function _chain_sort(p::Poset, ch::Vector{T}) where {T<:Integer}
    lt(x, y) = p[x] < p[y]
    return sort(ch; lt=lt)
end

"""
    induced_subposet(p::Poset, vlist::AbstractVector{T}) where {T<:Integer}

Create a new poset from `p` generated by the vertices in `vlist`.
"""
function induced_subposet(p::Poset, vlist::AbstractVector{T}) where {T<:Integer}
    g, m = induced_subgraph(p.d, vlist)
    q = Poset(g)
    return q, m
end

"""
    trim!(p::Poset)

Remove all vertices of `p` that have no relation to any other vertices.
"""
function trim!(p::Poset)
    while true
        n = nv(p)
        isolates = (v for v in 1:n if degree(p.d, v) == 0)
        try
            x = first(isolates)
            rem_vertex!(p, x)
        catch
            return nothing
        end
    end
end

"""
    vee(a::PosetElement, b::PosetElement)::PosetElement

Return the join of the two elements, or throw an error if no such join exists. 
Invoke like this: `p[x] ∨ p[y]`.
"""
function vee(a::PosetElement, b::PosetElement)::PosetElement
    p = a.p
    if p !== b.p   # different posets
        _cannot_compare()
    end

    # special case
    if a ≤ b
        return b
    end
    if a ≥ b
        return a
    end

    x = a.x
    y = b.x
    msg = "Elements $x and $y do not have a join in this poset"

    # these are the elements strictly above x and y
    overs = Set(above(p, x)) ∩ Set(above(p, y))

    if length(overs) == 0
        error(msg)
    end

    overlist = _chain_sort(p, collect(overs))

    z = first(overlist)  # candidate for the join 

    # check that z < every other element in overlist 
    no = length(overlist)

    for i in 2:no
        if !has_relation(p, z, overlist[i])
            error(msg)
        end
    end

    return p[z]
end

"""
    wedge(a::PosetElement, b::PosetElement)::PosetElement

Return the meet of the two elements, or throw an error if no such join exists. 
Invoke like this: `p[x] ∧ p[y]`.
"""
function wedge(a::PosetElement, b::PosetElement)::PosetElement
    p = a.p
    if p !== b.p   # different posets
        _cannot_compare()
    end

    # special case
    if a ≤ b
        return a
    end
    if a ≥ b
        return b
    end

    x = a.x
    y = b.x
    msg = "Elements $x and $y do not have a join in this poset"

    # these are the elements strictly above x and y
    unders = Set(below(p, x)) ∩ Set(below(p, y))

    if length(unders) == 0
        error(msg)
    end

    underlist = _chain_sort(p, collect(unders))

    z = last(underlist)  # candidate for the join 

    # check that z > every other element in underlist 
    no = length(underlist)

    for i in 1:(no - 1)
        if !has_relation(p, underlist[i], z)
            error(msg)
        end
    end

    return p[z]
end
