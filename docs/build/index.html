<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Posets · Posets</title><meta name="title" content="Posets · Posets"/><meta property="og:title" content="Posets · Posets"/><meta property="twitter:title" content="Posets · Posets"/><meta name="description" content="Documentation for Posets."/><meta property="og:description" content="Documentation for Posets."/><meta property="twitter:description" content="Documentation for Posets."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Posets</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Posets</a><ul class="internal"><li><a class="tocitem" href="#Introduction:-Partially-Ordered-Sets"><span>Introduction: Partially Ordered Sets</span></a></li><li><a class="tocitem" href="#Basics"><span>Basics</span></a></li><li><a class="tocitem" href="#Inspection"><span>Inspection</span></a></li><li><a class="tocitem" href="#Standard-Posets"><span>Standard Posets</span></a></li><li><a class="tocitem" href="#Graphs"><span>Graphs</span></a></li><li><a class="tocitem" href="#Matrices"><span>Matrices</span></a></li><li><a class="tocitem" href="#Operations"><span>Operations</span></a></li><li><a class="tocitem" href="#Implementation"><span>Implementation</span></a></li><li><a class="tocitem" href="#See-Also"><span>See Also</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Posets</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Posets</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/scheinerman/Posets.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/scheinerman/Posets.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Posets"><a class="docs-heading-anchor" href="#Posets">Posets</a><a id="Posets-1"></a><a class="docs-heading-anchor-permalink" href="#Posets" title="Permalink"></a></h1><p>Partially ordered sets for Julia based on <a href="https://juliagraphs.org/Graphs.jl/">Graphs</a>.</p><h2 id="Introduction:-Partially-Ordered-Sets"><a class="docs-heading-anchor" href="#Introduction:-Partially-Ordered-Sets">Introduction: Partially Ordered Sets</a><a id="Introduction:-Partially-Ordered-Sets-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction:-Partially-Ordered-Sets" title="Permalink"></a></h2><p>A <em>partially ordered set</em>, or <em>poset</em> for short, is a pair <span>$(V,\prec)$</span> where <span>$V$</span> is a set and <span>$\prec$</span> is a binary relation on <span>$V$</span> that is</p><ul><li><em>irreflexive</em> (for all <span>$v \in V$</span>, it is never the case that <span>$v \prec v$</span>),</li><li><em>antisymmetric</em> (for all <span>$v,w \in V$</span>, we never have both <span>$v \prec w$</span> and <span>$w \prec v$</span>), and</li><li><em>transitive</em> (for all <span>$u,v,w \in V$</span>, if <span>$u \prec v$</span> and <span>$v \prec w$</span> then <span>$u \prec w$</span>).</li></ul><p>Posets are naturally represented as transitively closed, directed, acyclic graphs. This is how this module implements posets using the <code>DiGraph</code> type in <code>Graphs</code>.</p><p>The design philosophy for this module is modeled exactly on <code>Graphs</code>. In particular, the vertex set of a poset is necessarily of the form <code>{1,2,...,n}</code>.</p><h2 id="Basics"><a class="docs-heading-anchor" href="#Basics">Basics</a><a id="Basics-1"></a><a class="docs-heading-anchor-permalink" href="#Basics" title="Permalink"></a></h2><h3 id="Construct-new-posets"><a class="docs-heading-anchor" href="#Construct-new-posets">Construct new posets</a><a id="Construct-new-posets-1"></a><a class="docs-heading-anchor-permalink" href="#Construct-new-posets" title="Permalink"></a></h3><p>Create a new poset with no elements using <code>Poset()</code> or a poset with a specified number  of elements with <code>Poset(n)</code>. </p><p>Given a poset <code>p</code>, use <code>Poset(p)</code> to create an independent copy of <code>p</code>.</p><p>Given a directed graph <code>d</code>, use <code>Poset(d)</code> to create a new poset from the transitive  closure of <code>d</code>. An error is thrown if <code>d</code> has cycles. (Self loops in <code>d</code> are ignored.)</p><p>Given a square matrix <code>A</code>, create a poset in which <code>i &lt; j</code> exactly when the <code>i,j</code>-entry  of <code>A</code> is nonzero. Diagonal entries are ignored. If this matrix would create a cycle, an  error is thrown. </p><h3 id="Adding-vertices-(elements)"><a class="docs-heading-anchor" href="#Adding-vertices-(elements)">Adding vertices (elements)</a><a id="Adding-vertices-(elements)-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-vertices-(elements)" title="Permalink"></a></h3><p>For consistency with <code>Graph</code>, we call the elements of a <code>Poset</code> <em>vertices</em> and the functions <code>add_vertex!</code> and <code>add_vertices!</code> work exactly as in the <code>Graphs</code> module.</p><pre><code class="nohighlight hljs">julia&gt; using Posets

julia&gt; p = Poset()
{0, 0} Int64 poset

julia&gt; add_vertex!(p)
true

julia&gt; add_vertices!(p,5)
5

julia&gt; p
{6, 0} Int64 poset</code></pre><p>Use <code>nv(p)</code> to return the number of elements (vertices) in <code>p</code>.</p><h3 id="Adding-a-relation"><a class="docs-heading-anchor" href="#Adding-a-relation">Adding a relation</a><a id="Adding-a-relation-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-a-relation" title="Permalink"></a></h3><p>To add a relation to a poset, use <code>add_relation!</code>. This returns <code>true</code> when successful.</p><pre><code class="nohighlight hljs">julia&gt; p = Poset(4)
{4, 0} Int64 poset

julia&gt; add_relation!(p,1,2)
true

julia&gt; add_relation!(p,2,3)
true

julia&gt; add_relation!(p,3,1)
false</code></pre><p>Let&#39;s look at this carefully to understand why the third call to <code>add_relation!</code> does not succeed:</p><ul><li>The first call to <code>add_relation!</code> causes the relation <code>1 &lt; 2</code> to hold in <code>p</code>. </li><li>The second call to <code>add_relation!</code> causes the relation <code>2 &lt; 3</code> to be added to <code>p</code>. Given that <code>1 &lt; 2</code> and <code>2 &lt; 3</code>, by transitivity we automatically have <code>1 &lt; 3</code> in <code>p</code>.</li><li>Therefore, we cannot add <code>3 &lt; 1</code> as a relation to this poset as that would violate antisymmetry.</li></ul><p>The <code>add_relation!</code> function may also be called as <code>add_relation!(p, (a,b))</code> or  <code>add_relation!(p, a =&gt; b)</code>. Both are equivalent to <code>add_relations(p, a, b)</code>.</p><h3 id="Adding-multiple-relations-(Danger!)"><a class="docs-heading-anchor" href="#Adding-multiple-relations-(Danger!)">Adding multiple relations (Danger!)</a><a id="Adding-multiple-relations-(Danger!)-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-multiple-relations-(Danger!)" title="Permalink"></a></h3><p>The addition of a relation to a poset can be somewhat slow.  Each addition involves error checking and calculations to ensure the integrity  of the underlying data structure. See the Implementation section at the end of this document.  Adding a list of relations one at a time can be inefficient, but it is safe. We also provide the function <code>add_relations!</code> (plural) that is more  efficient, but can cause serious problems. </p><p>To underscore the risk, this function  is not exported, but needs to be invoked as <code>Posets.add_relations!(p, rlist)</code>  where <code>rlist</code> is a list of either tuples <code>(a,b)</code> or pairs <code>a =&gt; b</code>. </p><p>Here is a good application of this function (although using <code>chain(10)</code> is safer):</p><pre><code class="nohighlight hljs">julia&gt; p = Poset(10)
{10, 0} Int64 poset

julia&gt; rlist = ((i,i+1) for i=1:9)
Base.Generator{UnitRange{Int64}, var&quot;#13#14&quot;}(var&quot;#13#14&quot;(), 1:9)

julia&gt; Posets.add_relations!(p, rlist)

julia&gt; p == chain(10)
true</code></pre><p>Here is what happens with misuse:</p><pre><code class="nohighlight hljs">julia&gt; p = Poset(5)
{5, 0} Int64 poset

julia&gt; rlist = [ 1=&gt;2, 2=&gt;3, 3=&gt;1 ]
3-element Vector{Pair{Int64, Int64}}:
 1 =&gt; 2
 2 =&gt; 3
 3 =&gt; 1

julia&gt; Posets.add_relations!(p, rlist)
ERROR: This poset has been become corrupted!</code></pre><h3 id="Removing-an-element"><a class="docs-heading-anchor" href="#Removing-an-element">Removing an element</a><a id="Removing-an-element-1"></a><a class="docs-heading-anchor-permalink" href="#Removing-an-element" title="Permalink"></a></h3><p>The function <code>rem_vertex!</code> behaves exactly as in <code>Graphs</code>. It removes the given vertex from the poset. For example:</p><pre><code class="nohighlight hljs">julia&gt; p = Poset(5)
{5, 0} Int64 poset

julia&gt; add_relation!(p,1,5)
true

julia&gt; rem_vertex!(p,2)
true

julia&gt; has_relation(p,1,2)
true</code></pre><p>When element <code>2</code> is removed from <code>p</code>, element <code>5</code> takes its place. Because of this renumbering,  we have some unexpected behavior:</p><pre><code class="nohighlight hljs">julia&gt; p = subset_lattice(4)
{16, 65} Int64 poset

julia&gt; q = Poset(p)   # make a copy of p
{16, 65} Int64 poset

julia&gt; rem_vertex!(q, 9)
true

julia&gt; q
{15, 57} Int64 poset

julia&gt; q ⊆ p
false

julia&gt; maximals(p) |&gt; collect
1-element Vector{Int64}:
 16

julia&gt; maximals(q) |&gt; collect
1-element Vector{Int64}:
 9</code></pre><p>One might expect that deleting a vertex from a poset results in a poset that is a subset of the original. However,  when vertex <code>9</code> was removed from (a copy of) <code>p</code>, the vertex <code>16</code> is relabeled <code>9</code>. Hence vertex <code>9</code> in <code>p</code> is not maximal, but it is maximal in <code>q</code>. </p><blockquote><p>For a more extensive explanation, see <a href="https://github.com/scheinerman/Posets.jl/blob/main/delete-doc/poset-deletion.pdf">poset-deletion.pdf</a> in the <code>delete-doc</code> folder. </p></blockquote><h3 id="Removing-a-relation"><a class="docs-heading-anchor" href="#Removing-a-relation">Removing a relation</a><a id="Removing-a-relation-1"></a><a class="docs-heading-anchor-permalink" href="#Removing-a-relation" title="Permalink"></a></h3><p>Removing relations from a poset is accomplished with <code>rem_relation!(p,a,b)</code>. Assuming <code>a&lt;b</code> in <code>p</code>, this deletes the relation <code>a&lt;b</code> from <code>p</code>, but also deletes all relations <code>a&lt;x</code> and <code>x&lt;b</code> for  vertices <code>x</code> that lie between <code>a</code> and <code>b</code>.</p><pre><code class="nohighlight hljs">julia&gt; p = chain(5)
{5, 10} Int64 poset

julia&gt; rem_relation!(p, 2, 4)
true

julia&gt; collect(relations(p))
8-element Vector{Relation{Int64}}:
 Relation 1 &lt; 2
 Relation 1 &lt; 3
 Relation 1 &lt; 4
 Relation 1 &lt; 5
 Relation 2 &lt; 4
 Relation 2 &lt; 5
 Relation 3 &lt; 5
 Relation 4 &lt; 5</code></pre><p>Note that relations <code>2&lt;3</code> and <code>3&lt;4</code> have been removed. </p><blockquote><p>For a more extensive explanation, see <a href="https://github.com/scheinerman/Posets.jl/blob/main/delete-doc/poset-deletion.pdf">poset-deletion.pdf</a> in the <code>delete-doc</code> folder. </p></blockquote><h2 id="Inspection"><a class="docs-heading-anchor" href="#Inspection">Inspection</a><a id="Inspection-1"></a><a class="docs-heading-anchor-permalink" href="#Inspection" title="Permalink"></a></h2><h3 id="Vertices"><a class="docs-heading-anchor" href="#Vertices">Vertices</a><a id="Vertices-1"></a><a class="docs-heading-anchor-permalink" href="#Vertices" title="Permalink"></a></h3><p>Use <code>nv(p)</code> to return the number of vertices in the poset <code>p</code>. As in <code>Graphs</code>, the  elements of the poset are integers from <code>1</code> to <code>n</code>. </p><p>Use <code>in(a, p)</code> [or <code>a ∈ p</code>] to determine if <code>a</code> is an element of <code>p</code>.  This is equivalent to <code>1 &lt;= a &lt;= nv(p)</code>.</p><h3 id="Relations"><a class="docs-heading-anchor" href="#Relations">Relations</a><a id="Relations-1"></a><a class="docs-heading-anchor-permalink" href="#Relations" title="Permalink"></a></h3><p>There are three ways to check if elements are related in a poset.</p><p>First, to see if  <code>1 &lt; 3</code> in <code>p</code> we use the <code>has_relation</code> function:</p><pre><code class="nohighlight hljs">julia&gt; has_relation(p,1,3)
true</code></pre><p>Second, the syntax <code>p(a,b)</code> is equivalent to <code>has_relation(p,a,b)</code>:</p><pre><code class="nohighlight hljs">julia&gt; p(1,3)
true

julia&gt; p(3,1)
false</code></pre><p>There is a third way to determine the relation between elements <code>a</code> and <code>b</code> in a poset <code>p</code>. Instead of <code>has_relation(p,a,b)</code> or <code>p(a,b)</code> we may use this instead: <code>p[a] &lt; p[b]</code>.</p><pre><code class="nohighlight hljs">julia&gt; has_relation(p,1,3)
true

julia&gt; p[1] &lt; p[3]
true

julia&gt; p[3] &lt; p[1]
false</code></pre><p>The other comparison operators (<code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code>) works as expected.</p><pre><code class="nohighlight hljs">julia&gt; p[3] &gt; p[1]
true</code></pre><p>Neither <code>has_relation(p,a,b)</code> nor <code>p(a,b)</code> generate errors; they return <code>false</code>  even if <code>a</code> or <code>b</code> are not elements of <code>p</code>. </p><pre><code class="nohighlight hljs">julia&gt; p(-2,9)
false</code></pre><p>However, the expression <code>p[a] &lt; p[b]</code>  throws an error in either of these situations:</p><ul><li>Using the syntax <code>p[a]</code> if <code>a</code> is not an element of <code>p</code>.</li><li>Trying to compare elements of different posets (even if the two posets are equal).</li></ul><h4 id="Comparability-check"><a class="docs-heading-anchor" href="#Comparability-check">Comparability check</a><a id="Comparability-check-1"></a><a class="docs-heading-anchor-permalink" href="#Comparability-check" title="Permalink"></a></h4><p>The functions <code>are_comparable(p,a,b)</code> and <code>are_incomparable(p,a,b)</code> behave as follows:</p><ul><li><code>are_comparable(p,a,b)</code> returns <code>true</code> exactly when <code>a</code> and <code>b</code> are both in the poset, and one of the following is true: <code>a&lt;b</code>, <code>a==b</code>, or <code>a&gt;b</code>. </li><li><code>are_incompable(p,a,b)</code> returns <code>true</code> exactly when <code>a</code> and <code>b</code> are both in the poset, but none of the follower are true: <code>a&lt;b</code>, <code>a==b</code>, or <code>a&gt;b</code>.</li></ul><p>Alternatively, use <code>p[a] ⟂ p[b]</code> to test if <code>a</code> and <code>b</code> are comparable, and use <code>p[a] ∥ p[b]</code> to test if <code>a</code> and <code>b</code> are incomparable. </p><h4 id="Chain/antichain-check"><a class="docs-heading-anchor" href="#Chain/antichain-check">Chain/antichain check</a><a id="Chain/antichain-check-1"></a><a class="docs-heading-anchor-permalink" href="#Chain/antichain-check" title="Permalink"></a></h4><p>Given a list of elements <code>vlist</code> of a poset <code>p</code>:</p><ul><li><code>is_chain(p, vlist)</code> returns <code>true</code> if the elements of <code>vlist</code> form a chain in <code>p</code>.</li><li><code>is_antichain(p, vlist)</code> returns <code>true</code> if the elements of <code>vlist</code> form an antichain in <code>p</code>.</li></ul><p>Both return <code>false</code> if an element of <code>vlist</code> is not in <code>p</code>.</p><h3 id="Counting/listing-relations"><a class="docs-heading-anchor" href="#Counting/listing-relations">Counting/listing relations</a><a id="Counting/listing-relations-1"></a><a class="docs-heading-anchor-permalink" href="#Counting/listing-relations" title="Permalink"></a></h3><p>Use <code>nr</code> to return the number of relations in the poset (this is analogous to <code>ne</code> in <code>Graphs</code>):</p><pre><code class="nohighlight hljs">julia&gt; nr(p)
3</code></pre><p>The function <code>relations</code> returns an iterator for all the relations in a poset.</p><pre><code class="nohighlight hljs">julia&gt; p = chain(4)
{4, 6} Int64 poset

julia&gt; collect(relations(p))
6-element Vector{Relation{Int64}}:
 Relation 1 &lt; 2
 Relation 1 &lt; 3
 Relation 1 &lt; 4
 Relation 2 &lt; 3
 Relation 2 &lt; 4
 Relation 3 &lt; 4</code></pre><p>The functions <code>src</code> and <code>dst</code> return the lesser and greater elements of a relation, respectively:</p><pre><code class="nohighlight hljs">julia&gt; r = first(relations(p))
Relation 1 &lt; 2

julia&gt; src(r), dst(r)
(1, 2)</code></pre><h3 id="Subset"><a class="docs-heading-anchor" href="#Subset">Subset</a><a id="Subset-1"></a><a class="docs-heading-anchor-permalink" href="#Subset" title="Permalink"></a></h3><ul><li><code>issubset(p,q)</code> (or <code>p ⊆ q</code>) returns <code>true</code> exactly when <code>nv(p) ≤ nv(q)</code> and whenever <code>v &lt; w</code> in <code>p</code> we also have <code>v &lt; w</code> in <code>q</code>.</li></ul><h3 id="Above,-below,-between"><a class="docs-heading-anchor" href="#Above,-below,-between">Above, below, between</a><a id="Above,-below,-between-1"></a><a class="docs-heading-anchor-permalink" href="#Above,-below,-between" title="Permalink"></a></h3><ul><li><code>above(p,a)</code> returns an iterator for all elements <code>k</code> of <code>p</code> such that <code>a&lt;k</code>.</li><li><code>below(p,a)</code> returns an iterator for all elements <code>k</code> of <code>p</code> such that <code>k&lt;a</code>.</li><li><code>between(p,a,b)</code> returns an iterator for all elements <code>k</code> of <code>p</code> such that <code>a&lt;k&lt;b</code>.</li></ul><pre><code class="nohighlight hljs">julia&gt; p = chain(10)
{10, 45} Int64 poset

julia&gt; collect(above(p,6))
4-element Vector{Int64}:
  7
  8
  9
 10

julia&gt; collect(below(p,6))
5-element Vector{Int64}:
 1
 2
 3
 4
 5

julia&gt; collect(between(p,3,7))
3-element Vector{Int64}:
 4
 5
 6</code></pre><h3 id="Covers"><a class="docs-heading-anchor" href="#Covers">Covers</a><a id="Covers-1"></a><a class="docs-heading-anchor-permalink" href="#Covers" title="Permalink"></a></h3><p>In a poset, we say <code>a</code> is covered by <code>b</code> provided <code>a &lt; b</code> and there is no element <code>c</code> such  that <code>a &lt; c &lt; b</code>.</p><p>Use <code>covered_by(p,a,b)</code> to determine if <code>a</code> is covered by <code>b</code>. Alternatively, use <code>p[a] &lt;&lt; p[b]</code> or <code>p[b] &gt;&gt; p[a]</code>.</p><pre><code class="nohighlight hljs">julia&gt; p = chain(8)
{8, 28} Int64 poset

julia&gt; p[4] &lt;&lt; p[5]
true

julia&gt; p[4] &lt;&lt; p[6]
false</code></pre><p>The functions <code>just_above</code> and <code>just_below</code> can be used to find elements that cover, or are covered by, a given vertex.</p><pre><code class="nohighlight hljs">julia&gt; p = chain(9)
{9, 36} Int64 poset

julia&gt; above(p,5) |&gt; collect
4-element Vector{Int64}:
 6
 7
 8
 9

julia&gt; just_above(p,5) |&gt; collect
1-element Vector{Int64}:
 6

julia&gt; below(p,5) |&gt; collect
4-element Vector{Int64}:
 1
 2
 3
 4

julia&gt; just_below(p,5) |&gt; collect
1-element Vector{Int64}:
 4</code></pre><h3 id="Maximals,-minimals,-height,-and-width"><a class="docs-heading-anchor" href="#Maximals,-minimals,-height,-and-width">Maximals, minimals, height, and width</a><a id="Maximals,-minimals,-height,-and-width-1"></a><a class="docs-heading-anchor-permalink" href="#Maximals,-minimals,-height,-and-width" title="Permalink"></a></h3><ul><li><p><code>maximals(p)</code> returns an iterator for the maximal elements of <code>p</code>.</p></li><li><p><code>minimals(p)</code> returns an iterator for the minimal elements of <code>p</code>.</p></li><li><p><code>maximum(p)</code> returns the maximum element of <code>p</code> or <code>0</code> if no such element exists. </p></li><li><p><code>minimum(p)</code> returns the minimum element of <code>p</code> or <code>0</code> if no such element exists.</p></li><li><p><code>max_chain(p)</code> returns a vector containing the elements of a largest chain in <code>p</code>.</p></li><li><p><code>max_antichain(p)</code> returns a vector containing the elements of a largest antichain in <code>p</code>.</p></li><li><p><code>height(p)</code> returns the size of a largest chain in <code>p</code>.</p></li><li><p><code>width(p)</code> returns the size of a largest antichain in <code>p</code>.</p></li><li><p><code>chain_cover(p)</code> returns a minimum-size collection of chains of <code>p</code> such that every element of   <code>p</code> is in one of the chains. The number of chains is the width of <code>p</code>. </p></li><li><p><code>antichain_cover(p)</code> returns a minimum-size collection of antichains of <code>p</code> such that   every element of <code>p</code> is in one of the antichains. The number of antichains is the height of <code>p</code>.</p></li></ul><blockquote><p><strong>Note</strong>: The function <code>max_chain</code> returns a largest chain in the poset. It is possible that there are two or more possible answers because there are two or more such chains of maximum size. There is no guarantee as to which largest chain will be returned. Likewise for <code>max_antichain</code>. Similarly, <code>chain_cover</code> returns a minimum-size partition of the elements into chains. If there are multiple minimum-size chain covers, there is no guarantee which will be returned by <code>chain_cover</code>. Likewise for <code>antichain_cover</code>.</p></blockquote><h3 id="Isomorphism"><a class="docs-heading-anchor" href="#Isomorphism">Isomorphism</a><a id="Isomorphism-1"></a><a class="docs-heading-anchor-permalink" href="#Isomorphism" title="Permalink"></a></h3><p>For posets <code>p</code> and <code>q</code>, use <code>iso(p,q)</code> to compute an isomorphism from <code>p</code> to <code>q</code>,  or throw an error if the posets are not isomorphic.</p><p>Let <code>f = iso(p,q)</code>. Then <code>f</code> is a <code>Dict</code> mapping vertices of <code>p</code> to vertices of <code>q</code>.  For example, if <code>p</code> has a unique minimal element <code>x</code>, then <code>f[x]</code> is the unique minimal element of <code>q</code>. </p><p>To check if posets are isomorphic, use <code>iso_check</code> (which calls <code>iso</code> inside a <code>try/catch</code> block).</p><h3 id="Realizers-and-dimension"><a class="docs-heading-anchor" href="#Realizers-and-dimension">Realizers and dimension</a><a id="Realizers-and-dimension-1"></a><a class="docs-heading-anchor-permalink" href="#Realizers-and-dimension" title="Permalink"></a></h3><p>A <em>realizer</em> for a poset <code>p</code> is a set of linear extensions whose intersection is <code>p</code>.  The function <code>realizer(p, d)</code> returns a list of <code>d</code> linear extensions (total orders)  that form a realizer of <code>p</code>, or throws an error if no realizer of that size exists.</p><pre><code class="nohighlight hljs">julia&gt; p = standard_example(3)
{6, 6} Int64 poset

julia&gt; r = realizer(p, 3)
3-element Vector{Poset{Int64}}:
 {6, 15} Int64 poset
 {6, 15} Int64 poset
 {6, 15} Int64 poset

julia&gt; r[1] ∩ r[2] ∩ r[3] == p
true

julia&gt; realizer(p, 2)
ERROR: This poset has dimension greater than 2; no realizer found.</code></pre><p>The <em>dimension</em> of a poset is the size of a smallest realizer. Use <code>dimension(p)</code>  to calculate its dimension. </p><pre><code class="nohighlight hljs">julia&gt; p = standard_example(4)
{8, 12} Int64 poset

julia&gt; dimension(p)
4</code></pre><blockquote><p><strong>Note</strong>: Computation of the dimension of a poset is NP-hard. The <code>dimension</code> function may be slow, even for moderate-size posets.</p></blockquote><h2 id="Standard-Posets"><a class="docs-heading-anchor" href="#Standard-Posets">Standard Posets</a><a id="Standard-Posets-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-Posets" title="Permalink"></a></h2><p>The following functions create standard partially ordered sets.  See the <a href="https://github.com/scheinerman/Posets.jl/blob/main/gallery/README.md">Gallery</a>  for pictures of some of these posets.</p><ul><li><p><code>antichain(n)</code> creates the poset with <code>n</code> elements and no relations. Same as <code>Poset(n)</code>.</p></li><li><p><code>chain(n)</code> creates the poset with <code>n</code> elements in which <code>1 &lt; 2 &lt; 3 &lt; ... &lt; n</code>. </p></li><li><p><code>chain(vlist)</code> creates a chain from the integer vector <code>vlist</code> (which must be a permutation of <code>1:n</code>). For example, <code>chain([2,1,3])</code> creates a chain in which <code>2 &lt; 1 &lt; 3</code>.</p></li><li><p><code>chevron()</code> creates a poset with <code>6</code> elements that has dimension equal to <code>3</code>. It is  different from <code>standard_example(3)</code>. </p></li><li><p><code>crown(n,k)</code> creates the crown poset with <code>2n</code> elements with two levels: <code>n</code> elements as minimals and <code>n</code> as maximals. Each minimal is comparable to <code>n-k</code> maximals. See the help message for more information.</p></li><li><p><code>random_linear_order(n)</code>: Create a linear order in which the numbers <code>1</code> through <code>n</code>  appear in random order.</p></li><li><p><code>random_poset(n,d=2)</code>: Create a random <code>d</code>-dimensional poset by intersecting <code>d</code> random linear orders, each with <code>n</code> elements. </p></li><li><p><code>standard_example(n)</code> creates a poset with <code>2n</code> elements. Elements <code>1</code> through <code>n</code> form an antichain  as do elements <code>n+1</code> through <code>2n</code>. The only relations are of the form <code>j &lt; k</code> where <code>1 ≤ j ≤ n</code>  and <code>k = n+i</code> where <code>1 ≤ i ≤ n</code> and <code>i ≠ j</code>. This is a smallest-size poset of dimension <code>n</code>. Equivalent to <code>crown(n,1)</code>.</p></li><li><p><code>subset_lattice(d)</code>: Create the poset corresponding to the <code>2^d</code> subsets of <code>{1,2,...,d}</code>  ordered by inclusion. For <code>a</code> between <code>1</code> and <code>2^d</code>, element <code>a</code> corresponds to a  subset of <code>{1,2,...,d}</code> as follows: Write <code>a-1</code> in binary and view the bits as the characteristic  vector indicating the members of the set. For example, if <code>a</code> equals <code>12</code>, then <code>a-1</code> is <code>1011</code> in  binary. Reading off the digits from the right, this gives the set <code>{1,2,4}</code>.  </p><ul><li>Use <code>subset_decode(a)</code> to convert an element <code>a</code> of this poset into a set of positive integers, <code>A</code>.</li><li>Use <code>subset_encode(A)</code> to convert a set of positive integers to its name in this poset. </li></ul></li><li><p><code>weak_order(vals)</code>: Create a weak order <code>p</code> from a list of real numbers. In <code>p</code> element <code>i</code> is less than element <code>j</code> provided <code>vals[i] &lt; vals[j]</code> .</p></li></ul><h2 id="Graphs"><a class="docs-heading-anchor" href="#Graphs">Graphs</a><a id="Graphs-1"></a><a class="docs-heading-anchor-permalink" href="#Graphs" title="Permalink"></a></h2><p>Let <code>p</code> be a poset. The following two functions create graphs from <code>p</code> with the same  vertex set as <code>p</code>:</p><ul><li><code>comparability_graph(p)</code> creates an undirected graph in which there is an edge from <code>v</code> to <code>w</code> exactly when <code>v &lt; w</code> or <code>w &lt; v</code> in <code>p</code>.</li><li><code>cover_digraph(p)</code> creates a directed graph in which there is an edge from <code>v</code> to <code>w</code> exactly when <code>v</code> is covered by <code>w</code>.</li></ul><pre><code class="nohighlight hljs">julia&gt; p = chain(9)
{9, 36} Int64 poset

julia&gt; g = comparability_graph(p)
{9, 36} undirected simple Int64 graph

julia&gt; g == complete_graph(9)
true

julia&gt; d = cover_digraph(p)
{9, 8} directed simple Int64 graph

julia&gt; d == path_digraph(9)
true</code></pre><p>Given a graph <code>g</code>, calling <code>vertex_edge_incidence_poset(p)</code> creates a poset whose elements correspond to the vertices and edges of <code>g</code>. In this poset the only relations are of the form <code>v &lt; e</code> where <code>v</code> is a vertex that is an end point of the edge <code>e</code>.</p><h2 id="Matrices"><a class="docs-heading-anchor" href="#Matrices">Matrices</a><a id="Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Matrices" title="Permalink"></a></h2><ul><li><code>zeta_matrix(p)</code> returns the zeta matrix of the poset. This is a <code>0,1</code>-matrix whose <code>i,j</code>-entry is <code>1</code> exactly when <code>p[i] ≤ p[j]</code>. </li><li><code>strict_zeta_matrix(p)</code> returns a  <code>0,1</code>-matrix whose <code>i,j</code> entry is <code>1</code>  exactly when <code>p[i] &lt; p[j]</code>.</li><li><code>mobius_matrix(p)</code> returns the inverse of <code>zeta(p)</code>. </li></ul><p>In all cases, the output is a dense, integer matrix. </p><h2 id="Operations"><a class="docs-heading-anchor" href="#Operations">Operations</a><a id="Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Operations" title="Permalink"></a></h2><h3 id="Dual"><a class="docs-heading-anchor" href="#Dual">Dual</a><a id="Dual-1"></a><a class="docs-heading-anchor-permalink" href="#Dual" title="Permalink"></a></h3><p>The dual of poset <code>p</code> is created using <code>reverse(p)</code>. This returns a new poset with the same elements as <code>p</code> in which all relations are reversed (i.e., <code>v &lt; w</code> in <code>p</code> if and  only if <code>w &lt; v</code> in <code>reverse(p)</code>). The dual (reverse) of <code>p</code> can also be created with <code>p&#39;</code>. </p><h3 id="Disjoint-union"><a class="docs-heading-anchor" href="#Disjoint-union">Disjoint union</a><a id="Disjoint-union-1"></a><a class="docs-heading-anchor-permalink" href="#Disjoint-union" title="Permalink"></a></h3><p>Given two posets <code>p</code> and <code>q</code>, the result of <code>p+q</code> is a new poset formed from the  disjoint union of <code>p</code> and <code>q</code>. Note that <code>p+q</code> and <code>q+p</code> are isomorphic, but  may be unequal because of the vertex numbering convention. </p><p>Alternatively <code>hcat(p,q)</code>.</p><h3 id="Stack"><a class="docs-heading-anchor" href="#Stack">Stack</a><a id="Stack-1"></a><a class="docs-heading-anchor-permalink" href="#Stack" title="Permalink"></a></h3><p>Given two posets <code>p</code> and <code>q</code>, the result of <code>p/q</code> is a new poset from a copy of <code>p</code>  and a copy of <code>q</code> with all elements of <code>p</code> above all elements of <code>q</code>. </p><p>Alternatively, <code>vcat(p,q)</code> or  <code>q\p</code>.</p><h3 id="Cartesian-product"><a class="docs-heading-anchor" href="#Cartesian-product">Cartesian product</a><a id="Cartesian-product-1"></a><a class="docs-heading-anchor-permalink" href="#Cartesian-product" title="Permalink"></a></h3><p>Given posets <span>$P$</span> and <span>$Q$</span>, their <em>Cartesian product</em>, <span>$P \times Q$</span>, is a poset whose  elements are all ordered pairs <span>$(a,b)$</span> where <span>$a$</span> is an element of <span>$P$</span> and <span>$b$</span> is an element of <span>$Q$</span>. In this poset we have <span>$(a,b)\preceq(c,d)$</span> if and only if <span>$a\preceq c$</span> in <span>$P$</span> and  <span>$b\preceq d$</span> in <span>$Q$</span>.</p><p>Cartesian product is implemented in <code>Posets</code> as <code>p * q</code>. The result is a new poset  that is isomorphic to the Cartesian product of <code>p</code> and <code>q</code>. </p><h3 id="Induced-subposet"><a class="docs-heading-anchor" href="#Induced-subposet">Induced subposet</a><a id="Induced-subposet-1"></a><a class="docs-heading-anchor-permalink" href="#Induced-subposet" title="Permalink"></a></h3><p>Given a poset <code>p</code> and a list of vertices <code>vlist</code>, use <code>induced_subposet(p)</code> to return a  pair <code>(q,vmap)</code>. The poset <code>q</code> is the induced subposet and the vector <code>vmap</code> maps the new vertices to the old ones  (the vertex <code>i</code> in the subposet corresponds to the vertex <code>vmap[i]</code> in <code>p</code>).</p><p>This is exactly analogous to <code>Graphs.induced_subgraph</code>. </p><h3 id="Intersection"><a class="docs-heading-anchor" href="#Intersection">Intersection</a><a id="Intersection-1"></a><a class="docs-heading-anchor-permalink" href="#Intersection" title="Permalink"></a></h3><p>Given two posets <code>p</code> and <code>q</code>, <code>intersect(p,q)</code> is a new poset in which <code>v &lt; w</code> if and only  if <code>v &lt; w</code> in both <code>p</code> and <code>q</code>. The number of elements is the smaller of <code>nv(p)</code> and <code>nv(q)</code>. This may also be invoked as <code>p ∩ q</code>. </p><p>For example, the intersection of a chain with its reversal has no relations:</p><pre><code class="nohighlight hljs">julia&gt; p = chain(5)
{5, 10} Int64 poset

julia&gt; p ∩ reverse(p)
{5, 0} Int64 poset</code></pre><h3 id="Linear-extension"><a class="docs-heading-anchor" href="#Linear-extension">Linear extension</a><a id="Linear-extension-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-extension" title="Permalink"></a></h3><p>Use <code>linear_extension(p)</code> to create  a linear extension of <code>p</code>.  This is a total order <code>q</code> with the same elements as <code>p</code> and with <code>p ⊆ q</code>. </p><h3 id="Join-and-meet"><a class="docs-heading-anchor" href="#Join-and-meet">Join and meet</a><a id="Join-and-meet-1"></a><a class="docs-heading-anchor-permalink" href="#Join-and-meet" title="Permalink"></a></h3><p>Let <span>$x$</span> and <span>$y$</span> be elements of a poset <span>$P$</span>.  Let <span>$U$</span> be the set of all elements <span>$z$</span> of <span>$P$</span> such that <span>$x \preceq z$</span> and <span>$y \preceq z$</span>.  This is the set of all elements above or equal to both <span>$x$</span> and <span>$y$</span>.  If <span>$U$</span> contains a minimum element (one that is below all the other elements of <span>$U$</span>),  then that minimum element <span>$u$</span> is the <em>join</em> of <span>$x$</span> and <span>$y$</span>. Notation <span>$u = x \vee y$</span>. </p><p>Similarly, let <span>$D$</span> be the set of all elements <span>$z$</span> of <span>$P$</span> such that  <span>$z \preceq x$</span> and <span>$z \preceq y$</span>. This is the set of all elements in <span>$P$</span> that are below or equal to <span>$x$</span> and <span>$y$</span>. If <span>$D$</span> contains a unique maximum element (one that is above all the other elements in <span>$D$</span>), then that maximum element <span>$d$</span> is the  <em>meet</em> of <span>$x$</span> and <span>$y$</span>. Notation: <span>$d = x \wedge y$</span>. </p><p>There are two ways to compute the join [or meet] of elements in a poset. </p><ul><li>The join and meet of elements <code>x</code> and <code>y</code> in poset <code>p</code> can be computed as <code>p[x] ∨ p[y]</code> and <code>p[x] ∧ p[y]</code>.</li><li>Or use the functions <code>lattice_join(p,x,y)</code> or <code>lattice_meet(p,x,y)</code></li></ul><p><strong>Important notes</strong>:</p><ul><li>The meet [or join] of two elements need not exist.<ul><li>In the operation form, <code>p[x] ∧ p[y]</code> [or <code>p[x] ∨ p[y]</code>], if there is no meet [or join], an error is thrown.</li><li>In the function form, <code>lattice_meet(p,x,y)</code> [or <code>lattice_join(x,y)</code>], if there is no meet [or join] then <code>0</code> is returned. </li></ul></li><li>Cannot compute the meet [or join] of elements in different posets. </li><li>The expression <code>p[x]</code> throws an error if <code>x</code> is not an element of <code>p</code>. </li><li>The symbol <code>∨</code> is typed <code>\vee&lt;TAB&gt;</code> and <code>∧</code> is typed <code>\wedge&lt;TAB&gt;</code>.</li><li>The result of <code>p[x] ∨ p[y]</code> is an object of type <code>PosetElement</code> (likewise for <code>∧</code>). </li><li>The result of <code>lattice_join</code> [or <code>lattice_meet</code>] is always an integer. The return value of <code>0</code> is used to show that the join [or meet] does not exist. </li></ul><p>The join and meet operations for posets are analogous to union and intersection for sets as illustrated here:</p><pre><code class="nohighlight hljs">julia&gt; using ShowSet

julia&gt; p = subset_lattice(4)
{16, 65} Int64 poset

julia&gt; A = Set([1,2,3])
{1,2,3}

julia&gt; B = Set([2,3,4])
{2,3,4}

julia&gt; a = subset_encode(A)
8

julia&gt; b = subset_encode(B)
15

julia&gt; p[a] ∨ p[b]
Element 16 in a {16, 65} Int64 poset

julia&gt; subset_decode(integer(ans))
{1,2,3,4}

julia&gt; p[a] ∧ p[b]
Element 7 in a {16, 65} Int64 poset

julia&gt; subset_decode(integer(ans))
{2,3}</code></pre><p>Further, the function <code>join_table(p)</code> [or <code>meet_table</code>] creates a matrix  whose <code>i,j</code>-entry is the join [or meet] of elements <code>i</code> and <code>j</code> in poset <code>p</code>,  or <code>0</code> if the join [or meet] doesn&#39;t exist.</p><h2 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h2><p>A <code>Poset</code> is a structure that contains a single data element: a <code>DiGraph</code>.  Users should not be accessing this directly, but it may be useful to understand how posets are implemented. The directed graph is acyclic (including loopless) and transitively closed. This means if <span>$a \to b$</span> is an edge and <span>$b\to c$</span> is an edge, then <span>$a \to c$</span> is also an edge. The advantage to this structure is that checking if <span>$a \prec b$</span> in a poset is quick. There are two disadvantages.</p><p>First, the graph may be larger than needed. If we only kept cover edges  (the transitive reduction of the digraph) we might have many fewer edges.  For example, a linear order with <span>$n$</span> elements has <span>$\binom{n}{2} \sim n^2/2$</span>  edges in the digraph that represents it, whereas there are only <span>$n-1$</span> edges in  the cover digraph. However, this savings is an extreme example. A poset with <span>$n$</span> elements split into two antichains, with every element of the first antichain below every element of the second, has <span>$n^2/4$</span> edges in either representation.  So in either case, the representing digraph may have up to order <span>$n^2$</span> edges. </p><p>Second, the computational cost of adding (or deleting) a relation is nontrivial.  The <code>add_relation!</code> function first checks if the added relation would violate  transitivity; this is speedy because we can add the relation <span>$a \prec b$</span> so  long as we don&#39;t have <span>$b\prec a$</span> already in the poset. However, after the edge <span>$(a,b)$</span>  is inserted into the digraph, we execute <code>transitiveclosure!</code> and that takes some  work. Adding several relations to the poset, one at a time, can be slow. </p><p>This can be greatly accelerated by using <code>Posets.add_relations!</code> but (as discussed above) this function can cause severe problems if not used carefully.</p><h2 id="See-Also"><a class="docs-heading-anchor" href="#See-Also">See Also</a><a id="See-Also-1"></a><a class="docs-heading-anchor-permalink" href="#See-Also" title="Permalink"></a></h2><p>The <code>extras</code> folder includes additional code that may be useful in  working with <code>Posets</code>. See the <code>README</code> in the <code>extras</code> directory. </p><p>Of note is <code>extras/converter.jl</code> that defines the function <code>poset_converter</code> that can  be used to transform a <code>Poset</code> (defined in this module) to a <code>SimplePoset</code>  (defined in the <a href="https://github.com/scheinerman/SimplePosets.jl">SimplePosets</a> module). </p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Thursday 29 August 2024 16:52">Thursday 29 August 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
