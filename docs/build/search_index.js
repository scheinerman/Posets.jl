var documenterSearchIndex = {"docs":
[{"location":"#Posets","page":"Posets","title":"Posets","text":"","category":"section"},{"location":"","page":"Posets","title":"Posets","text":"Partially ordered sets for Julia based on Graphs.","category":"page"},{"location":"#Introduction:-Partially-Ordered-Sets","page":"Posets","title":"Introduction: Partially Ordered Sets","text":"","category":"section"},{"location":"","page":"Posets","title":"Posets","text":"A partially ordered set, or poset for short, is a pair (V) where V is a set and  is a binary relation on V that is","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"irreflexive (for all v in V, it is never the case that v  v),\nantisymmetric (for all vw in V, we never have both v  w and w  v), and\ntransitive (for all uvw in V, if u  v and v  w then u  w).","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"Posets are naturally represented as transitively closed, directed, acyclic graphs. This is how this module implements posets using the DiGraph type in Graphs.","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"The design philosophy for this module is modeled exactly on Graphs. In particular, the vertex set of a poset is necessarily of the form {1,2,...,n}.","category":"page"},{"location":"#Basics","page":"Posets","title":"Basics","text":"","category":"section"},{"location":"#Construct-new-posets","page":"Posets","title":"Construct new posets","text":"","category":"section"},{"location":"","page":"Posets","title":"Posets","text":"Create a new poset with no elements using Poset() or a poset with a specified number  of elements with Poset(n). ","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"Given a poset p, use Poset(p) to create an independent copy of p.","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"Given a directed graph d, use Poset(d) to create a new poset from the transitive  closure of d. An error is thrown if d has cycles. (Self loops in d are ignored.)","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"Given a square matrix A, create a poset in which i < j exactly when the i,j-entry  of A is nonzero. Diagonal entries are ignored. If this matrix would create a cycle, an  error is thrown. ","category":"page"},{"location":"#Adding-elements","page":"Posets","title":"Adding elements","text":"","category":"section"},{"location":"","page":"Posets","title":"Posets","text":"For consistency with Graph, we call the elements of a Poset vertices and the functions add_vertex! and add_vertices! work exactly as in the Graphs module.","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"julia> using Posets\n\njulia> p = Poset()\n{0, 0} Int64 poset\n\njulia> add_vertex!(p)\ntrue\n\njulia> add_vertices!(p,5)\n5\n\njulia> p\n{6, 0} Int64 poset","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"Use nv(p) to return the number of elements (vertices) in p.","category":"page"},{"location":"#Adding-relations","page":"Posets","title":"Adding relations","text":"","category":"section"},{"location":"","page":"Posets","title":"Posets","text":"To add a relation to a poset, use add_relation!. This returns true when successful.","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"julia> p = Poset(4)\n{4, 0} Int64 poset\n\njulia> add_relation!(p,1,2)\ntrue\n\njulia> add_relation!(p,2,3)\ntrue\n\njulia> add_relation!(p,3,1)\nfalse","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"Let's look at this carefully to understand why the third call to add_relation! does not succeed:","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"The first call to add_relation! causes the relation 1 < 2 to hold in p. \nThe second call to add_relation! causes the relation 2 < 3 to be added to p. Given that 1 < 2 and 2 < 3, by transitivity we automatically have 1 < 3 in p.\nTherefore, we cannot add 3 < 1 as a relation to this poset as that would violate antisymmetry.","category":"page"},{"location":"#Removing-elements","page":"Posets","title":"Removing elements","text":"","category":"section"},{"location":"","page":"Posets","title":"Posets","text":"The function rem_vertex! behaves exactly as in Graphs. It removes the given vertex from the poset. For example:","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"julia> p = Poset(5)\n{5, 0} Int64 poset\n\njulia> add_relation!(p,1,5)\ntrue\n\njulia> rem_vertex!(p,2)\ntrue\n\njulia> has_relation(p,1,2)\ntrue","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"When element 2 is removed from p, element 5 takes its place. ","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"The rem_vertices! function is not part of the official API for Graphs and so we have not defined rem_vertices! for Posets.","category":"page"},{"location":"#Removing-relations","page":"Posets","title":"Removing relations","text":"","category":"section"},{"location":"","page":"Posets","title":"Posets","text":"Removal of relations not implemented yet.","category":"page"},{"location":"#Inspection","page":"Posets","title":"Inspection","text":"","category":"section"},{"location":"#Vertices","page":"Posets","title":"Vertices","text":"","category":"section"},{"location":"","page":"Posets","title":"Posets","text":"Use nv(p) to return the number of vertices in the poset p. As in Graphs, the  elements of the poset are integers from 1 to n. ","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"Use in(a, p) [or a ∈ p] to determine if a is an element of p.  This is equivalent to 1 <= a <= nv(p).","category":"page"},{"location":"#Relations","page":"Posets","title":"Relations","text":"","category":"section"},{"location":"","page":"Posets","title":"Posets","text":"There are three ways to check if elements are related in a poset.","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"First, to see if  1 < 3 in p we use the has_relation function:","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"julia> has_relation(p,1,3)\ntrue","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"Second, the syntax p(a,b) is equivalent to has_relation(p,a,b):","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"julia> p(1,3)\ntrue\n\njulia> p(3,1)\nfalse","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"There is a third way to determine the relation between elements a and b in a poset p. Instead of has_relation(p,a,b) or p(a,b) we may use this instead: p[a] < p[b].","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"julia> has_relation(p,1,3)\ntrue\n\njulia> p[1] < p[3]\ntrue\n\njulia> p[3] < p[1]\nfalse","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"The other comparison operators (<=, >, >=, ==, !=) works as expected.","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"julia> p[3] > p[1]\ntrue","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"Neither has_relation(p,a,b) nor p(a,b) generate errors; they return false  even if a or b are not elements of p. ","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"julia> p(-2,9)\nfalse","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"However, the expression p[a] < p[b]  throws an error in either of these situations:","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"Using the syntax p[a] if a is not an element of p.\nTrying to compare elements of different posets (even if the two posets are equal).","category":"page"},{"location":"#Comparability-check","page":"Posets","title":"Comparability check","text":"","category":"section"},{"location":"","page":"Posets","title":"Posets","text":"The functions are_comparable(p,a,b) and are_incomparable(p,a,b) behave as follows:","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"are_comparable(p,a,b) returns true exactly when a and b are both in the poset, ","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"and one of the following is true: a<b, a==b, or a>b.","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"are_incompable(p,a,b) returns true exactly when a and b are both in the poset, ","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"but none of the follower are true: a<b, a==b, or a>b.","category":"page"},{"location":"#Chain/antichain-check","page":"Posets","title":"Chain/antichain check","text":"","category":"section"},{"location":"","page":"Posets","title":"Posets","text":"Given a list of elements vlist of a poset p:","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"is_chain(p, vlist) returns true if the elements of vlist form a chain in p.\nis_antichain(p, vlist) returns true if the elements of vlist form an antichain in p.","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"Both return false if an element of vlist is not in p.","category":"page"},{"location":"#Counting/listing-relations","page":"Posets","title":"Counting/listing relations","text":"","category":"section"},{"location":"","page":"Posets","title":"Posets","text":"Use nr to return the number of relations in the poset (this is analogous to ne in Graphs):","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"julia> nr(p)\n3","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"The function relations returns an iterator for all the relations in a poset.","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"julia> p = chain(4)\n{4, 6} Int64 poset\n\njulia> collect(relations(p))\n6-element Vector{Relation{Int64}}:\n Relation 1 < 2\n Relation 1 < 3\n Relation 1 < 4\n Relation 2 < 3\n Relation 2 < 4\n Relation 3 < 4","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"The functions src and dst return the lesser and greater elements of a relation, respectively:","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"julia> r = first(relations(p))\nRelation 1 < 2\n\njulia> src(r), dst(r)\n(1, 2)","category":"page"},{"location":"#Subset","page":"Posets","title":"Subset","text":"","category":"section"},{"location":"","page":"Posets","title":"Posets","text":"issubset(p,q) (or p ⊆ q) returns true exactly when nv(p) ≤ nv(q) and whenever v < w in ","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"p we also have v < w in q.","category":"page"},{"location":"#Above,-Below,-Between","page":"Posets","title":"Above, Below, Between","text":"","category":"section"},{"location":"","page":"Posets","title":"Posets","text":"above(p,a) returns an iterator for all elements k of p such that a<k.\nbelow(p,a) returns an iterator for all elements k of p such that k<a.\nbetween(p,a,b) returns an iterator for all elements k of p such that a<k<b.","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"julia> p = chain(10)\n{10, 45} Int64 poset\n\njulia> collect(above(p,6))\n4-element Vector{Int64}:\n  7\n  8\n  9\n 10\n\njulia> collect(below(p,6))\n5-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n\njulia> collect(between(p,3,7))\n3-element Vector{Int64}:\n 4\n 5\n 6","category":"page"},{"location":"#Covers","page":"Posets","title":"Covers","text":"","category":"section"},{"location":"","page":"Posets","title":"Posets","text":"In a poset, we say a is covered by b provided a < b and there is no element c such  that a < c < b.","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"Use covered_by(p,a,b) to determine if a is covered by b. Alternatively, use p[a] << p[b] or p[b] >> p[a].","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"julia> p = chain(8)\n{8, 28} Int64 poset\n\njulia> p[4] << p[5]\ntrue\n\njulia> p[4] << p[6]\nfalse","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"The functions just_above and just_below can be used to find elements that cover, or are covered by, a given vertex.","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"julia> p = chain(9)\n{9, 36} Int64 poset\n\njulia> above(p,5) |> collect\n4-element Vector{Int64}:\n 6\n 7\n 8\n 9\n\njulia> just_above(p,5) |> collect\n1-element Vector{Int64}:\n 6\n\njulia> below(p,5) |> collect\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> just_below(p,5) |> collect\n1-element Vector{Int64}:\n 4","category":"page"},{"location":"#Maxmals/Minimals/Height/Width","page":"Posets","title":"Maxmals/Minimals/Height/Width","text":"","category":"section"},{"location":"","page":"Posets","title":"Posets","text":"maximals(p) returns an iterator for the maximal elements of p.\nminimals(p) returns an iterator for the minimal elements of p.\nmax_chain(p) returns a vector containing the elements of a largest chain in p.\nmax_antichain(p) returns a vector containing the elements of a largest antichain in p.\nheight(p) returns the size of a largest chain in p.\nwidth(p) returns the size of a largest antichain in p.\nchain_cover(p, k) returns a collection of k chains of p such that every element of ","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"p is in one of the chains. The parameter k is optional, in which case the width of p  is used. (This is the smallest possible size of a chain cover per Dilworth's theorem.)","category":"page"},{"location":"#Isomorphism","page":"Posets","title":"Isomorphism","text":"","category":"section"},{"location":"","page":"Posets","title":"Posets","text":"For posets p and q, use iso(p,q) to compute an isomorphism from p to q,  or throw an error if the posets are not isomorphic.","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"Let f = iso(p,q). Then f is a Dict mapping vertices of p to vertices of q.  For example, if p has a unique minimal element x, then f[x] is the unique minimal element of q. ","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"To check if posets are isomorphic, use iso_check (which calls iso inside a try/catch block).","category":"page"},{"location":"#Realizers-and-dimension","page":"Posets","title":"Realizers and dimension","text":"","category":"section"},{"location":"","page":"Posets","title":"Posets","text":"A realizer for a poset p is a set of linear extensions whose intersection is p.  The function realizer(p, d) returns a list of d linear extensions (total orders)  that form a realizer of p, or throws an error if no realizer of that size exists.","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"julia> p = standard_example(3)\n{6, 6} Int64 poset\n\njulia> r = realizer(p, 3)\n3-element Vector{Poset{Int64}}:\n {6, 15} Int64 poset\n {6, 15} Int64 poset\n {6, 15} Int64 poset\n\njulia> r[1] ∩ r[2] ∩ r[3] == p\ntrue\n\njulia> realizer(p, 2)\nERROR: This poset has dimension greater than 2; no realizer found.","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"The dimension of a poset is the size of a smallest realizer. Use dimension(p)  to calculate its dimension. ","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"julia> p = standard_example(4)\n{8, 12} Int64 poset\n\njulia> dimension(p)\n4","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"Note: Computation of the dimension of a poset is NP-hard. The dimension function may be","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"slow, even for moderate-size posets.","category":"page"},{"location":"#Standard-Posets","page":"Posets","title":"Standard Posets","text":"","category":"section"},{"location":"","page":"Posets","title":"Posets","text":"The following functions create standard partially ordered sets.","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"chain(n) creates the poset with n elements in which 1 < 2 < 3 < ... < n. \nchain(vlist) creates a chain from the integer vector vlist (which must be a permutation of 1:n). ","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"For example, chain([2,1,3]) creates a chain in which 2 < 1 < 3.","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"antichain(n) creates the poset with n elements and no relations. Same as Poset(n).\nstandard_example(n) creates a poset with 2n elements. Elements 1 through n form an antichain ","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"as do elements n+1 through 2n. The only relations are of the form j < k where 1 ≤ j ≤ n  and k = n+i where 1 ≤ i ≤ n and i ≠ j. This is a smallest-size poset of dimension n.","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"chevron() creates a poset with 6 elements that has dimension equal to 3. It is ","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"different from standard_example(3). ","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"random_linear_order(n): Create a linear order in which the numbers 1 through n appear in ","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"random order.","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"random_poset(n,d=2): Create a random d-dimensional poset by intersecting d random linear orders,","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"each with n elements. ","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"subset_lattice(d): Create the poset corresponding to the 2^d subsets of {1,2,...,d} ","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"ordered by inclusion. For a between 1 and 2^d, element a corresponds to a  subset of {1,2,...,d} as follows: Write a-1 in binary and view the bits as the characteristic  vector indicating the members of the set. For example, if a equals 12, then a-1 is 1011 in  binary. Reading off the digits from the right, this gives the set {1,2,4}.  ","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"Use subset_decode(a) to convert an element a of this poset into a set of positive ","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"integers, A.","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"Use subset_encode(A) to convert a set of positive integers to its name in this poset. ","category":"page"},{"location":"#Graphs","page":"Posets","title":"Graphs","text":"","category":"section"},{"location":"","page":"Posets","title":"Posets","text":"Let p be a poset. The following two functions create graphs from p with the same  vertex set as p:","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"comparability_graph(p) creates an undirected graph in which there is an edge from v to w exactly when v < w or w < v in p.\ncover_digraph(p) creates a directed graph in which there is an edge from v to w exactly when v is covered by w.","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"julia> p = chain(9)\n{9, 36} Int64 poset\n\njulia> g = comparability_graph(p)\n{9, 36} undirected simple Int64 graph\n\njulia> g == complete_graph(9)\ntrue\n\njulia> d = cover_digraph(p)\n{9, 8} directed simple Int64 graph\n\njulia> d == path_digraph(9)\ntrue","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"Given a graph g, calling vertex_edge_incidence_poset(p) creates a poset whose elements correspond to the vertices and edges of g. In this poset the only relations are of the form v < e where v is a vertex that is an end point of the edge e.","category":"page"},{"location":"#Matrices","page":"Posets","title":"Matrices","text":"","category":"section"},{"location":"","page":"Posets","title":"Posets","text":"zeta_matrix(p) returns the zeta matrix of the poset. This is a 0,1-matrix whose","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"i,j-entry is 1 exactly when p[i] ≤ p[j]. ","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"mobius_matrix(p) returns the inverse of zeta(p). ","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"In both cases, the output is a dense, integer matrix. ","category":"page"},{"location":"#Operations","page":"Posets","title":"Operations","text":"","category":"section"},{"location":"#Dual","page":"Posets","title":"Dual","text":"","category":"section"},{"location":"","page":"Posets","title":"Posets","text":"The dual of poset p is created using reverse(p). This returns a new poset with the same elements as p in which all relations are reversed (i.e., v < w in p if and  only if w < v in reverse(p)). The dual (reverse) of p can also be created with p'. ","category":"page"},{"location":"#Disjoint-union","page":"Posets","title":"Disjoint union","text":"","category":"section"},{"location":"","page":"Posets","title":"Posets","text":"Given two posets p and q, the result of p+q is a new poset formed from the  disjoint union of p and q. Note that p+q and q+p are isomorphic, but  may be unequal because of the vertex numbering convention.","category":"page"},{"location":"#Stack","page":"Posets","title":"Stack","text":"","category":"section"},{"location":"","page":"Posets","title":"Posets","text":"Given two posets p and q, the result of p/q is a new poset from from a copy of p  and a copy of q with all elements of p above all elements of q. ","category":"page"},{"location":"#Induced-subposet","page":"Posets","title":"Induced subposet","text":"","category":"section"},{"location":"","page":"Posets","title":"Posets","text":"Given a poset p and a list of vertices vlist, use induced_subposet(p) to return a  pair (q,vmap). The poset q is the induced subposet and the vector vmap maps the new vertices to the old ones  (the vertex i in the subposet corresponds to the vertex vmap[i] in p).","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"This is exactly analogous to Graphs.induced_subgraph. ","category":"page"},{"location":"#Intersection","page":"Posets","title":"Intersection","text":"","category":"section"},{"location":"","page":"Posets","title":"Posets","text":"Given two posets p and q, intersect(p,q) is a new poset in which v < w if and only  if v < w in both p and q. The number of elements is the smaller of nv(p) and nv(q). This may also be invoked as p ∩ q. ","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"For example, the intersection of a chain with its reversal has no relations:","category":"page"},{"location":"","page":"Posets","title":"Posets","text":"julia> p = chain(5)\n{5, 10} Int64 poset\n\njulia> p ∩ reverse(p)\n{5, 0} Int64 poset","category":"page"},{"location":"#Linear-extension","page":"Posets","title":"Linear extension","text":"","category":"section"},{"location":"","page":"Posets","title":"Posets","text":"Use linear_extension(p) to create  a linear extension of p.  This is a total order q with the same elements as p and with p ⊆ q. ","category":"page"},{"location":"#See-Also","page":"Posets","title":"See Also","text":"","category":"section"},{"location":"","page":"Posets","title":"Posets","text":"The extras folder includes additional code that may be useful in  working with Posets. See the README in that directory. ","category":"page"}]
}
